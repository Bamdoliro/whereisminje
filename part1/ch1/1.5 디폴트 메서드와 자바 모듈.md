지금까지 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였다. 게다가 이러한 패키지의 인터페이스를 바꿔야 하는 상황에서는 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 했으므로 매우 고통스러웠다.

# 모듈

자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다. 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.<br><br>

# 디폴트 메서드

디폴트 메서드를 이용하면 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공한다.

```java
List<Apple> heavyApples1 =
inventory.stream().filter((Apple a) -> a.getWeight() > 150)
                  .collect(toList()); List<Apple> heavyApples2 =
inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
                          .collect(toList())
```

자바 8 이전에는 List\<T>(List가 구현하는 인터페이스인 Collection\<T>도 마찬가지)가 stream이나 parallelStream 메서드를 지원하지 않았다.(여기서 T는 그냥 형식 파라미터이다.) 따라서 위 예제를 컴파일하려면 Collection 인터페이스에 stream메서드를 추가하고 ArrayList 클래스에서 메서드를 구현해야한다. 하지만 이미 컬렉션 API의 인터페이스를 구현하는 많은 컬렉션 프레임워크가 존재하므로, 인터페이스에 새로운 메서드를 추가한다면 인터페이스를 구현하는 모든 클래스는 새로 추가된 메서드를 구현해야 한다.<br><br>

하지만 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다(그래서 이를 디폴트 메서드<sup>default method</sup>라고 부른다).

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. (이 디폴트 메서드는 정적 메서드인 Collections.sort를 호출한다).

```java
default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}
```

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.<br><br>

그런데 하나의 클래스에서 여러 인터페이스를 구현할 수 있다 -> 여러 인터페이스에 다중 디폴트 메서드가 존재할 수 있다 -> 다중 상속이 허용된다?

엄밀히 다중 상속은 아니지만 어느정도는 '그렇다'라고 말할 수 있다.
