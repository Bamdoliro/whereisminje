4장에서는 스트림을 이용해서 **외부 반복**을 **내부 반복**으로 바꾸는 방법을 살펴봤다.
다음은 데이터 컬렉션 반복을 명시적으로 관리하는 외부 반복 코드이다.

```java
List<Dish> vegetarianDishes = new ArrayList<>();
for(Dish d: menu) {
	if(d.isVegetarian()) {
		vegetarianDishes.add(d);
	}
}
```
명시적 반복 대신 filter와 collect 연산을 지원하는 스트림 API를 이용해서 데이터 컬렉션 반복을 내부적으로 처리할 수 있다. 다음처럼 filter 메서드에 필터링 연산을 인수로 넘겨주면된다.
```java
List<Dish> vegetarianDishes =
	menu.steam()
		.filter(Dish::isVegetarian)
		.collect(toList());
```
스트림 내부적으로 다양한 최적화가 이루어질 수 있다. 스트림 API는 내부 반복 뿐 아니라 코드를 병렬로 실행할지 여부도 결정할 수 있다. 이러한 일은 순차적인 반복을 단일 스레드로 구현하는 외부 반복으로는 달성할 수 없다.

### 5.1.1 프레디케이트로 필터링
스트림 인터페이스는 filter 메서드를 지원한다. filter 메서드는 프레디케이트(boolean을 반환하는 함수)를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

### 5.1.2 고유 요소 필터링
스트림은 고유 요소로 이루어진 스트림을 반환하는 distinct 메서드도 지원한다.(고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정된다)
예를 들어 다음 코드는 리스트의 모든 짝수를 선택하고 중복을 필터링한다.
```java
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
	.filter(i -> i % 2 == 0)
	.distinct()
	.forEach(System.out::println);
```