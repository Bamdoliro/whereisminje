### 스트림이란 정확히 멀까?

스트림이란 '데이터 처리 연산을 지원하도록 소스에서 추출된 연속의 요소'로 정의할 수 있다.
- **연속된 요소** : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값집합의 인터페이스를 제공한다. 컬렉션은 자료구조 이므로 컬렉션에서는 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. 반면, 표현 계산식이 주를 이룬다. 즉, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다. 

- **소스** : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로 부터 데이터를 소비한다. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다. 즉, 리스트로 스트림을 만들면 둘 다 같은 순서를 유지한다.

- **데이터 처리 연산** : 스트림은 함수형 언어에서 일반적으로 지원하는 연산과 DB와 비슷한 연산을 지원한다.

또한 스트림에는 2가지 중요 특징이 있다.

- **파이프 라이닝** : 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다. 그 덕분에 **게으름**, **쇼트서킷** 같은 최적화도 얻을 수 있다.

- **내부 반복** : 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

지금까지의 내용을 예제로 확인하자
```java
List<String> threeHighCaloricDishNames =
	menu.stream()  // <- 메뉴에서 스트림을 얻는다
		.filter(dish -> dish.getCalories() > 300) // <- 파이프 라인 연산 만들기
		.map(Dish::getName) // <- 요리명 추출
		.limit(3) // <- 선착순 세 개만 선택
		.collect(toList());
```

menu에 stream메서드를 호출해서 스트림을 얻었다. 여기서 **데이터 소스**는 요리 리스트다.
데이터 소스는 **연속된 요소**를 스트림에 제공한다. 다음으로 스트림에 filter, map, limit, collect로 이어지는 일련의 **데이터 처리 연산**을 적용한다. collect를 제외한 모든 연산은 서로 **파이프라인**을 형성할 수 있도록 스트림을 반환한다. 

파이프라인은 소스에 적용하는 질의 같은 존재다. 마지막으로 collect 연사능로 파이프라인을 처리해서 결과(List)를 반환한다.

마지막에 collect를 호출하기 전 까지는 menu에서 무엇도 선택되지 않으면 출력 결과도 없다. 즉, 호출되기 전 까지는 메서드 호출이 저장되는 효과가 있다.

- filter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다.

- map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다.

- limit : 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소 truncate한다.

- collect : 다양한 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 반환시키는 기능을 수행하는 것 이다. 예제의 toList()는 스트림을 리스트로 변환하라고 지시하는 인수이다. 