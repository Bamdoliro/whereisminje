컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.
여기서 **연속된**이라는 표현은 순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근한다는 것을 의미한다. 

#### 컬렉션과 스트림의 차이
- 시각적인 차이
	- DVD에 어떤 영화가 저장되어 있다 하자. DVD에 전체 자료구조가 저장되어 있으므로 DVD도 컬렉션이다. 이번에는 DVD가 아니라 **인터넷 스트리밍**으로 같은 비디오를 시청한다고 하자. 스트리밍. 즉 스트림이 등장했다. 스트리밍으로 재생할 때는 사용자가 시청하는 부분의 몇 프레임을 미리 내려받는다. 그러면 스트림의 다른 대부분의 값을 처리하지 않은 상태에서 미리 내려 받은 프레임 부터 재생할 수 있다. 특히 비디오 재생기에는 메모리가 모지랄 수 도 있다. 충분한 메모리가 있더라도 모든 프레임을 내려받은 다음에 재생을 시작하면 오랜 시간이 걸릴 수 도 있다. 스트림 일부를 컬렉션으로 저장하도록 할 수 있지만 주제에 벗어나는 이야기이다.

	- 데이터를 **언제** 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다. 컬랙션은 현재 자료구조가 포함하는 **모든** 값을 메모리에 저장하는 구조다. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전 계산되어야 한다. (컬렉션에 요소를 추가하거나 컬렉션의 요소를 삭제할 수 있다. 이런 연산을 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계산 되어야 한다.)

	- 반면 스트림은 **이론적으로 요청할 때만 요소를 계산**하는 고정된 자료구조다.(스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없다) 스트림은 사용자가 요청하는 값만 스트림에서 추출한다는 것이 핵심이다. 물론 사용자 입장에서는 이러한 변화를 알 수 없다. 결과적으로 스트림은 생산자와 소비자 관계를 형성한다. 또한 스트림은 게으르게 만들어지는 컬렉션과 같다. 즉, 사용자가 데이터를 요청할 때만 값을 계산한다.(경영학에서는 이를 요청 중심 제조 또는 즉석 제조라고 부른다)

	- 반면 컬렉션은 적극적으로 생성된다.(생산자 중심 : 팔기도 전에 창고를 가득 채움) 만약 소수를 계산한다고 가정하면 끝이 없는 소수를 계산하고 추가하기를 반복하여 소비자는 결과를 얻지 못할 것이다.
-  브라우저 인터넷 검색
	- 구글에 검색어를 입력했다고 가정하자. 그림을 포함한 모든 검색 결과를 내려받을 때까지 기다리지 않아도 가장 비슷한 10개 또는 20개의 결과 요소를 포함하는 스트림을 얻을 수 있다. 다음 10개 버튼을 누르면 요청을 받아들여 계산한 다음 결과를 반환 할 것이다.
### 4.3.1 딱 한번만 탐색할 수 있다
반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다. 즉, 탐색된 스트림의 요소는 소비된다. 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.(그러려면 컬렉션처럼 반복 사용할 수 있는 데이터 소스여야 한다. 만일 데이터소스가 I/O 채널이라면 소스를 반복사용할 수 없으므로 새로운 스트림을 만들 수 없다)
```java
List<String> title = Arrays.asList("Bam", "dol", "i", "ro");
Stream<String> s = title.stream();
s.forEach(System.out::println); // <- title의 각 단어를 출력
s.forEach(System.out::println); // <- java.lanIllegalStateException: 스트림이 이미 소비 되었거나 닫힘
```
스트림은 단 한 번만 소비할 수 있다는 점을 명심하자

컬랙션과 스트림의 또 다른 차이점은 데이터 반복 처리 방법이다.

### 4.3.2 외부 반복과 내부 반복
컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다 이를 **외부 반복**이라고 한다. 반면 스트림 라이브러리는 (반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는) **내부 반복**을 사용한다. 함수에 어떤 작업을 수행 할지만 지정하면 모든 것이 알아서 처리된다. 다음 코드를 보면
```java
List<String> names = new ArrayList<>();
for(Dish dish: menu) { // <- 메뉴 리스트를 명시적으로 순차 반복한다.
	names.add(dish.getName()); // <- 이름을 추출해서 리스트에 추가한다.
}
```
for-each 구문은 반복자를 사용하는 불편함을 어느정도 해결해준다. for-each를 이용하면 Iterator 객체를 이용하는 것보다 더 쉽게 컬렉션을 반복할 수 있다.

컬랙션: 내부적으로 숨겨졌던 반복자를 사용한 외부 반복
```java
List<String> names = new ArrayList<>();
Iterator<String> iterator = menu.iterator();
while(iterator.hasNext()) {
	Dish dish = iterator.next();
	names.add(dish.getName());
}
```

스트림: 내부 반복
```java
List<String> names = menu.stream()
/* map메서드를 getName 메서드로 파라미터화해서 요리명을 추천한다. */									.map(Dish::getName)
		.collect(toList());
/* 파이프를 실행한다 반복자는 필요없다 -> */
```

내부 반복은 외부 반복과 어떤 점이 다르며 어떤 이득을 주는지 예제를 통해 살펴보자. 소피아에게 인형을 정리하라고 말하는 상황이다.
```
마리오 : "소피아, 장난감 좀 정리하렴. 방바닥에 장난감이 있지?"
소피아 : "네, 공이 있어요"
마리오 : "좋아, 그럼 공을 상자에 담자. 또 어떤 장난감이 있지?"
소피아 : "인형이 있어요."
마리오 : "그럼 인형을 상자에 담자. 또 어떤 장난감이 있지?"
소피아 : "책이 있어요."
마리오 : "그럼 책을 상자에 담자. 또 어떤 장난감이 있지?"
소피아 : "아무것도 없어요."
마리오 : "참 잘했어."
```
우리는 위 대화처럼 자바 컬렉션을 사용한다. 컬렉션은 **외부적으로** 반복, 즉 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다. '소피아, 바닥에 있는 모든 장난감을 상자에 담자'라고 말하면 좋을 것이다. 내부 반복이 좋은 이유는 2가지가 더 있다. 첫째로 소피아가 한 손에는 인형을 다른 한 손에는 공을 동시에 들 수 있다는 점이고, 둘째로 먼저 모든 장난감을 상자 가까이 이동 시킨 다음에 장난감을 상자에 넣을 수 있다는 점이다. 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다. 반면 for-each를 이용하는 외부 반복에서는 병렬성을 **스스로 관리**해야 한다.

지금까지 컬렉션과 스트림의 개념적 차이를 살펴봤다. 특히 스트림은 내부 반복을 사용하므로 반복 과정을 우리가 신경 쓰지 않아도 된다. 하지만 이와 같은 이점을 누리려면 (filter와 map 같이) 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다. 반복을 숨겨주는 대부분의 연산은 람다 표현식을 인수로 받으므로 3장에서 배운 동작 파라미터화를 활용할 수 있다. 